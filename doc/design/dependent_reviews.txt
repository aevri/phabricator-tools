===============================================================================
= Proposal to add support for dependency between reviews and commits
===============================================================================

The current Arcyd workflow squashes commits when landing, which puts people
off if they are working on a chain of dependent commits.  This proposal
includes support for dependencies between commits, which builds the foundation
for dependency chain support.

-------------------------------------------------------------------------------
- Motivation
-------------------------------------------------------------------------------

It's generally considered good practice to make separate commits for logically
separate changes.  Usually when separating large changes there are dependencies
between the resulting commits.

With the current Arcyd workflow it is not easy to land changes that depend
on eachother.  The simplest thing is to submit one change for review at a
time and gradually work through the stack (or tree) of dependencies from
root to tips.

We need a better way.

-------------------------------------------------------------------------------
- Review one change per branch, allow dependencies between branches
-------------------------------------------------------------------------------

Taking this feature branch as an example:

  * (master) latest change on master
  |
  | * (feature/mychanges) Thing: extend the warble garble
  | * Thing: extend the frobnitz munger
  | * Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (figure 0) simple feature branch

There are a number of schemes we might pursue to enable review of the branch
with Phabricator:

  1. 'audit' - push the branch and audit each commit in 'Diffusion', lose all
     review information if history is re-written.  Without being able to
     rewrite history then perhaps 'git commit --fixup' can be used to introduce
     changes destined to patch individual commits.
     'git rebase -i --autosquash' can be used to apply the fixups, this won't
     always go cleanly and the process will dispose of all commit comments.

  2. 'drip from local' - push one commit for review at a time as a new review
     branch.  Once a review lands then rebase the branch on master and push
     the next commit for review.  When commits are independent then they may
     of course be pushed as review branches at the same time.
     This process works but feels far too manual.

  3. 'dependent review branches' - push each commit as a new branch and somehow
     encode the dependency information in the name of the branch, probably
     using the existing 'base' portion of the branch naming scheme.  Review
     branches that are based on review branches can be treated differently to
     remove all the manual process that would be required in method '2'.

  4. 'branch reviews' - create a single Differential review for the whole
     branch.  This may create a large, inseperable review out of commits that
     were originally logically separate changes.  To aid the reviewer, when
     creating the review we can submit each commit as a separate 'update' to
     the Differential review.  This will have the advantage of allowing the
     reviewer to examine the inter-update diffs to break down the review.
     All inline comments should be made on the most recent version of the files
     or the comments may not be easily visible to the author.
     Subsequent updates in response to the review might be made by rebase-edit
     or fixup commits, either way they will appear as separate updates to the
     review, the diffs of of the original commits will not be updated.
     All commits will have to land at the same time, i.e. if only the last
     commit on the branch has actions from the review then none of them will
     land until they are all approved.

It seems like approach (3) 'dependent review branches' and (4) 'branch reviews'
are the most promising.

The main advantages of (3) are that:

+ The commits may move independently, so they land as early as possible.

+ The commits may move independently, so it's not "all or nothing".

+ The commits are viewed and commented upon independently, since they are
  logically seperate then this may reduce the complexity of the individual
  reviews quite a lot.

+ The commits are versioned individually and are easy to edit in isolation,
  authors may simply check out the review branch and make fixup commits with
  semi-meaningful messages without fear that the messages will make it into the
  final revision.

+ Once the commits have been separated onto branches, this is the same workflow
  that all parties involved would normally go through.

+ It's possible for other authors to explicitly depend on a
  'review-in-progress', so they don't have to wait for it to land in order to
  safely begin their work.  Since the depended-on branch will land as early as
  possible then there is a minimum of waiting in the system as a whole.

The main drawback of (3) seems to be the burden of creating a new branch per
commit.  This seems like a task suitable for a helper tool and is really just
the general burden of creating a review branch multiplied by the number of
commits on the branch.

There are a number of approaches we might take to lessen that admin burden.

This proposal will focus exclusively on approach (3) and leave discussion of
the others as a matter for other proposals.

-------------------------------------------------------------------------------
- Dependencies encoded in branch names
-------------------------------------------------------------------------------

Taking this feature branch as an example:

  * (master) latest change on master
  |
  | * (feature/mychanges) Thing: extend the warble garble
  | * Thing: extend the frobnitz munger
  | * Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (copy of figure 0) simple feature branch

If we adopt the 'r' branch syntax then we could re-render
'feature/mychanges' for review as dependent but separate review branches:

  r/refactorThing
  r/r/refactorThing/extendThing
  r/r/r/refactorThing/extendThing/extendThingMore

  (figure 1) regular branch dependency

This looks a bit messy, perhaps this would be better:

  r/refactorThing
  r/refactorThing/extendThing
  r/refactorThing/extendThing/extendThingMore

  (figure 2) abbreviated branch dependency

Sadly this isn't possible with git - branches can't have other branches as
prefixes.  This is because 'r/refactorThing' is the path to a file, so by
file-system rules we can't have another file at path
'r/refactorThing/extendThing'.

Alternatively, if we transpose 'base' and 'description' then we get:

  r/refactorThing
  r/extendThing/refactorThing
  r/extendThingMore/extendThing/refactorThing

  (figure 3) abbrev. branch dependency, transpose 'base' and 'description'

Another workaround might be to allow for suffixes to avoid collisions:

  r/refactorThing/r
  r/refactorThing/extendThing/r
  r/refactorThing/extendThing/extendThingMore/r

  (figure 4) abbrev. branch dependency, add suffixes

This last scheme has the huge advantages of being possible and also aided by
regular bash / Git auto-complete.  Once you have a base branch then you should
be able to 'tab' your way to success and avoid frustrating typos.

-------------------------------------------------------------------------------
- Comparison of encoding schemes
-------------------------------------------------------------------------------

There are 4 schemes outlines in the previous section, here they are assigned
letters for easier discussion:

A - (figure 1) - regular branch dependency
B - (figure 2) - abbreviated branch dependency
C - (figure 3) - abbrev. branch dependency, transpose 'base' and 'description'
D - (figure 4) - abbrev. branch dependency, add suffixes

There are at least three criteria to compare them by:

"length" - the length of the resulting branches, the shorter the better

"unambiguity" - in some schemes it's possible for the "base" to alias to more
                than one branch.  For example in scheme 'D' the branches:
                  'refactorThing', 'r/refactorThing', 'r/refactorThing/r' are
                all possible matches for the base of:
                  'r/refactorThing/extendThing/r'

"sorts to hierarchy" - whether or not sorting the list of branch names
                       organises them by some sort of hierarchy.

In this table we assign scores to each scheme for each of the criteria and add
up the totals:

                      | A | B | C | D |
  |-------------------|---------------|
  |length             | 0 | 2 | 2 | 1 |
  |unambiguity        | 2 | 1 | 1 | 0 |
  |sorts to hierarchy | 1 | 2 | 0 | 2 |
  |-------------------|----------------
  |TOTAL              | 3 | 5 | 3 | 3 |

  (figure 5) comparison of encoding schemes

It appears that scheme 'B' is a clear winner but unfortunately it is not
possible due to the limitation of Git outlined earlier.  All other contenders
score equally.

It appears the remaining choice is the relative importance of 'length',
'unambiguity' and 'sorts to hierarchy'.

The great advantage of 'sorts to hierarchy' is that regular Git / bash
autocomplete can aid in the composition of branch names.

Given that readability and auto-complete are probably the most important
considerations then it would make sense to prioritise sorts to hierarchy
and length, therefore sceme 'D' would seem to be the logical choice.

-------------------------------------------------------------------------------
- Assisted branch creation approaches
-------------------------------------------------------------------------------

Here are some explorations of possible schemes for assisting users in creating
valid review hierarchies.

Taking this feature branch as an example again:

  * (master) latest change on master
  |
  | * (feature/mychanges) Thing: extend the warble garble
  | * Thing: extend the frobnitz munger
  | * Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (copy of figure 0) simple feature branch

We could generate the required review branches manually like so:

  $ git checkout feature/mychanges
  $ git push origin HEAD~2:refs/heads/r/noHung/r
  $ git push origin HEAD~1:refs/heads/r/noHung/extendFrob/r
  $ git push origin HEAD~0:refs/heads/r/noHung/extendFrob/Warb/r

  (figure 6) manual submission of review branches

Making this branch structure:

  * (master) latest change on master
  |
  | * (feature/mychanges, origin/r/noHung/extendFrob/Warb/r) Thing: extend the
  | * (origin/r/noHung/extendFrob/r) Thing: extend the frobnitz munger
  | * (origin/r/noHung/r) Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (figure 7) simple feature branch pushed for review

This process could be made less verbose with a trivial git alias:

  $ git config alias.pushdep \
    '! f() {git push origin HEAD~$1:refs/heads/r/$2/r}; f()'

  $ git pushdep 2 noHung
  $ git pushdep 1 noHung/extendFrob
  $ git pushdep 0 noHung/extendFrob/Warb

  (figure 7) manual submission of review branches

We could also make an interactive script to reduce burden further:

  $ push-dependent-branches
  0520cc2 Thing: refactor, remove hungarian notation
  one word description >> noHung

  5dff3fc Thing: extend the frobnitz munger
  one word description >> extendFrob

  4c8effd (feature/mychanges) Thing: extend the warble garble
  one word description >> Warb

  (figure 8) interactive iterative spawning of review branches

Of course, you'd want something more user-friendly than this but it's not hard
to imagine how it could be extended.

Yet another approach could follow the example of 'git rebase --interactive' in
presenting the user with a simple 'program' to edit, leveraging the power of
editors like 'vim' to reduce the typing burden.

  base master
  push DESCRIPTION 0520cc2 Thing: refactor, remove hungarian notation
  push DESCRIPTION 5dff3fc Thing: extend the frobnitz munger
  push DESCRIPTION 4c8effd Thing: extend the warble garble

  # Split 0520cc2..4c8e44d into dependent branches
  #
  # Commands:
  #  b, base = set the current base ref (can match a DESCRIPTION)
  #  p, push = use commit, be sure to edit 'DESCRIPTION'
  #  r, reword = use commit, but edit the commit message
  #
  # These lines can be re-ordered; they are executed from top to bottom.
  #
  # If you remove a line here THAT COMMIT WILL NOT BE USED.
  #
  # However, if you remove everything, the splitting will be aborted.
  #
  # Note that empty commits are commented out

  (figure 9) interactive 'branch-split' session

If we want to get a little carried away then we can go even further and create
a tree out of the commits, with the assumption that 'Warb' does not depend on
'extendFrob':

  base master
  push noHung 0520cc2 Thing: refactor, remove hungarian notation
  push extendFrob 5dff3fc Thing: extend the frobnitz munger

  base noHung
  push Warb 4c8effd Thing: extend the warble garble

  # Split 0520cc2..4c8e44d into dependent branches
  #
  # Commands:
  #  b, base = set the current base ref (can match a DESCRIPTION)
  #  p, push = use commit, be sure to edit 'DESCRIPTION'
  #  r, reword = use commit, but edit the commit message
  #
  # These lines can be re-ordered; they are executed from top to bottom.
  #
  # If you remove a line here THAT COMMIT WILL NOT BE USED.
  #
  # However, if you remove everything, the splitting will be aborted.
  #
  # Note that empty commits are commented out

  (figure 10) advanced interactive 'branch-split' session

This would make the following branch structure:

  * (master) latest change on master
  |
  | * (origin/r/noHung/Warb/r) Thing: extend the wable garble
  | |
  | | * (feature/mychanges) Thing: extend the warble garble
  | | * (origin/r/noHung/extendFrob/r) Thing: extend the frobnitz munger
  | |/
  | * (origin/r/noHung/r) Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (figure 11) advanced feature branch pushed for review

Although creating the branch hierarchy is an additional burden it appears that
there are some good options for reducing it require effort on only the things
a human is required for.

-------------------------------------------------------------------------------
- Branch dependency workflow
-------------------------------------------------------------------------------

Given that we have a robust scheme for encoding the dependencies between
branches and creating the hierarchy of dependent branches then we may explore
various use-cases for the workflow.

Taking the advanced example from the previous section:

  * (master) latest change on master
  |
  | * (origin/r/noHung/Warb/r) Thing: extend the wable garble
  | |
  | | * (feature/mychanges) Thing: extend the warble garble
  | | * (origin/r/noHung/extendFrob/r) Thing: extend the frobnitz munger
  | |/
  | * (origin/r/noHung/r) Thing: refactor, remove hungarian notation
  |/
  * commit that's the merge-base

  - (copy of figure 11) advanced feature branch pushed for review

